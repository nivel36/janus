/*
 * Copyright 2025 Abel Ferrer Jim√©nez
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package es.nivel36.janus.service.schedule;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import es.nivel36.janus.util.Strings;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;

/**
 * JPA entity representing a rule within a {@link Schedule}.
 *
 * <p>
 * A {@code ScheduleRule} defines a concrete set of time configurations that
 * apply to specific days of the week and, optionally, to a limited date range.
 * Typical use cases include defining standard working hours, seasonal schedules
 * (e.g. summer hours), or exceptional periods.
 * </p>
 *
 * <p>
 * Each rule belongs to exactly one {@link Schedule} and aggregates multiple
 * {@link DayOfWeekTimeRange} instances, which describe the effective time
 * ranges for individual days of the week.
 * </p>
 *
 * <p>
 * From a business perspective, rules are uniquely identified by their
 * {@code name} within the context of a schedule. Equality and hash code are
 * therefore based on this attribute.
 * </p>
 */
@Entity
public class ScheduleRule implements Serializable {

	private static final long serialVersionUID = 1L;

	/**
	 * Surrogate primary key of the schedule rule.
	 *
	 * <p>
	 * This value is auto-generated by the persistence provider and has no business
	 * meaning.
	 * </p>
	 */
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	/**
	 * Human-readable name of the schedule rule.
	 *
	 * <p>
	 * This field is mandatory and must not be {@code null} or empty.
	 * </p>
	 */
	@NotEmpty
	private String name;

	/**
	 * The schedule to which this rule belongs.
	 *
	 * <p>
	 * This association is mandatory and immutable once the rule has been persisted.
	 * </p>
	 */
	@NotNull
	@ManyToOne(optional = false, fetch = FetchType.LAZY)
	@JoinColumn(name = "schedule_id", updatable = false)
	private Schedule schedule;

	/**
	 * Start date of the rule validity period.
	 *
	 * <p>
	 * May be {@code null} to indicate that the rule is valid from the beginning of
	 * the schedule.
	 * </p>
	 */
	private LocalDate startDate;

	/**
	 * End date of the rule validity period.
	 *
	 * <p>
	 * May be {@code null} to indicate that the rule is valid indefinitely.
	 * </p>
	 */
	private LocalDate endDate;

	/**
	 * Day-of-week time ranges defined by this rule.
	 *
	 * <p>
	 * Each {@link DayOfWeekTimeRange} specifies the effective time range for a
	 * specific {@link java.time.DayOfWeek}. The returned collection must be treated
	 * as read-only from outside the entity.
	 * </p>
	 */
	@OneToMany(mappedBy = "scheduleRule", cascade = CascadeType.ALL, orphanRemoval = true)
	private List<DayOfWeekTimeRange> dayOfWeekRanges = new ArrayList<>();

	/**
	 * Protected no-argument constructor required by persistence frameworks.
	 *
	 * <p>
	 * This constructor must not be used directly in application code. It exists
	 * solely to allow frameworks such as JPA to instantiate the entity.
	 * </p>
	 */
	ScheduleRule() {
	}

	/**
	 * Creates a new {@code ScheduleRule} with the given name and parent schedule.
	 *
	 * @param name     the human-readable name of the rule; must not be {@code null}
	 *                 or blank
	 * @param schedule the {@link Schedule} to which this rule belongs; must not be
	 *                 {@code null}
	 *
	 * @throws NullPointerException     if {@code schedule} is {@code null}
	 * @throws IllegalArgumentException if {@code name} is {@code null} or blank
	 */
	public ScheduleRule(final String name, final Schedule schedule) {
		this.name = Strings.requireNonBlank(name, "name can't be null or blank");
		this.schedule = Objects.requireNonNull(schedule, "schedule can't be null");
	}

	/**
	 * Returns the surrogate identifier of this schedule rule.
	 *
	 * @return the internal identifier, or {@code null} if the entity has not yet
	 *         been persisted
	 */
	public Long getId() {
		return this.id;
	}

	/**
	 * Assigns the surrogate identifier of this schedule rule.
	 *
	 * <p>
	 * This method exists exclusively for testing purposes and must not be used in
	 * production code.
	 * </p>
	 *
	 * @param id the identifier to assign
	 */
	void setId(final Long id) {
		this.id = id;
	}

	/**
	 * Returns the human-readable name of this rule.
	 *
	 * @return the rule name
	 */
	public String getName() {
		return this.name;
	}

	/**
	 * Updates the human-readable name of this rule.
	 *
	 * @param name the new rule name; must not be {@code null} or blank
	 * @throws IllegalArgumentException if {@code name} is blank
	 */
	public void setName(final String name) {
		this.name = Strings.requireNonBlank(name, "name can't be null or blank");
	}

	/**
	 * Returns the schedule to which this rule belongs.
	 *
	 * @return the parent {@link Schedule}
	 */
	public Schedule getSchedule() {
		return this.schedule;
	}

	/**
	 * Returns the start date of the rule validity period.
	 *
	 * @return the start date, or {@code null} if the rule has no lower bound
	 */
	public LocalDate getStartDate() {
		return this.startDate;
	}

	/**
	 * Returns the end date of the rule validity period.
	 *
	 * @return the end date, or {@code null} if the rule has no upper bound
	 */
	public LocalDate getEndDate() {
		return this.endDate;
	}

	/**
	 * Defines the validity period of this schedule rule.
	 *
	 * <p>
	 * Either {@code startDate}, {@code endDate}, or both may be {@code null},
	 * indicating an open-ended validity range. When both dates are present,
	 * {@code endDate} must not be before {@code startDate}.
	 * </p>
	 *
	 * @param startDate the start date of the validity period, or {@code null}
	 * @param endDate   the end date of the validity period, or {@code null}
	 *
	 * @throws IllegalArgumentException if both dates are provided and
	 *                                  {@code endDate} is before {@code startDate}
	 */
	public void setActivePeriod(final LocalDate startDate, final LocalDate endDate) {
		if (startDate != null && endDate != null && endDate.isBefore(startDate)) {
			throw new IllegalArgumentException("endDate must not be before startDate");
		}
		this.startDate = startDate;
		this.endDate = endDate;
	}

	/**
	 * Returns an unmodifiable view of the day-of-week time ranges defined by this
	 * rule.
	 *
	 * @return an unmodifiable list of {@link DayOfWeekTimeRange} instances
	 */
	public List<DayOfWeekTimeRange> getDayOfWeekRanges() {
		return Collections.unmodifiableList(this.dayOfWeekRanges);
	}

	/**
	 * Adds a day-of-week time range to this rule.
	 *
	 * @param range the {@link DayOfWeekTimeRange} to add; must not be {@code null}
	 * @return {@code true} if the range was not already present
	 * @throws NullPointerException if {@code range} is {@code null}
	 */
	public boolean addRange(final DayOfWeekTimeRange range) {
		Objects.requireNonNull(range, "range can't be null");
		return this.dayOfWeekRanges.add(range);
	}

	/**
	 * Removes a day-of-week time range from this rule.
	 *
	 * @param range the {@link DayOfWeekTimeRange} to remove; must not be
	 *              {@code null}
	 * @return {@code true} if the range was present and removed
	 * @throws NullPointerException if {@code range} is {@code null}
	 */
	public boolean removeRange(final DayOfWeekTimeRange range) {
		Objects.requireNonNull(range, "range can't be null");
		return this.dayOfWeekRanges.remove(range);
	}

	@Override
	public int hashCode() {
		return Objects.hash(this.name, this.schedule);
	}

	@Override
	public boolean equals(final Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || this.getClass() != obj.getClass()) {
			return false;
		}
		final ScheduleRule other = (ScheduleRule) obj;
		return Objects.equals(this.name, other.name) && Objects.equals(this.schedule, other.schedule);
	}

	@Override
	public String toString() {
		return this.schedule + " - " + this.name;
	}
}
