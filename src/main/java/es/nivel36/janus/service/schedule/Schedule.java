/*
 * Copyright 2026 Abel Ferrer Jim√©nez
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package es.nivel36.janus.service.schedule;

import java.io.Serializable;
import java.util.Collections;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import org.hibernate.annotations.NaturalId;

import es.nivel36.janus.service.employee.Employee;
import es.nivel36.janus.util.Strings;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.validation.constraints.NotEmpty;

/**
 * JPA entity representing a work schedule.
 *
 * <p>
 * A {@code Schedule} defines a set of temporal rules that describe when work is
 * expected to be performed. These rules are expressed as {@link ScheduleRule}
 * instances and may vary by day of the week or by specific date ranges (for
 * example, seasonal or holiday schedules).
 * </p>
 *
 * <p>
 * The entity is identified internally by a surrogate primary key, while the
 * {@code code} field acts as a natural identifier with business meaning.
 * Equality and hash code are therefore based exclusively on this natural
 * identifier.
 * </p>
 */
@Entity
public class Schedule implements Serializable {

	private static final long serialVersionUID = 1L;

	/**
	 * Surrogate primary key of the schedule.
	 *
	 * <p>
	 * This value is auto-generated by the persistence provider and has no business
	 * meaning. It must not be used for equality comparisons.
	 * </p>
	 */
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	/**
	 * Human-readable name of the schedule.
	 *
	 * <p>
	 * This field is mandatory and must not be {@code null} or empty.
	 * </p>
	 */
	@NotEmpty
	private String name;

	/**
	 * Unique business code of the schedule.
	 *
	 * <p>
	 * Acts as a natural identifier for lookups and external references. This value
	 * is immutable once the entity has been persisted.
	 * </p>
	 */
	@NaturalId
	@NotEmpty
	@Column(updatable = false)
	private String code;

	/**
	 * Set of rules that define the temporal behavior of this schedule.
	 *
	 * <p>
	 * Each {@link ScheduleRule} describes a concrete time configuration, such as
	 * working hours for a given day of the week or a specific date range. This
	 * association uses cascade and orphan removal semantics.
	 * </p>
	 */
	@OneToMany(mappedBy = "schedule", cascade = CascadeType.ALL, orphanRemoval = true)
	private final Set<ScheduleRule> rules = new HashSet<>();

	/**
	 * Set of employees assigned to this schedule.
	 *
	 * <p>
	 * This association represents the inverse side of the relationship defined in
	 * {@link Employee}. The returned collection must be treated as read-only from
	 * outside the entity.
	 * </p>
	 */
	@OneToMany(mappedBy = "schedule")
	private Set<Employee> employees = new HashSet<>();

	/**
	 * Protected no-argument constructor required by persistence frameworks.
	 *
	 * <p>
	 * This constructor must not be used directly in application code. It exists
	 * solely to allow frameworks such as JPA to instantiate the entity.
	 * </p>
	 */
	Schedule() {
	}

	/**
	 * Creates a new {@code Schedule} with the given business code and name.
	 *
	 * <p>
	 * The {@code code} acts as a natural identifier and must be unique. The
	 * {@code name} provides a human-readable description of the schedule.
	 * </p>
	 *
	 * @param code the unique business code of the schedule; must not be
	 *             {@code null}
	 * @param name the human-readable name of the schedule; must not be {@code null}
	 * @throws NullPointerException if {@code code} or {@code name} is {@code null}
	 */
	public Schedule(final String code, final String name) {
		this.code = Objects.requireNonNull(code, "code can't be null");
		this.name = Objects.requireNonNull(name, "name can't be null");
	}

	/**
	 * Returns the surrogate identifier of the schedule.
	 *
	 * @return the internal identifier, or {@code null} if the entity has not yet
	 *         been persisted
	 */
	public Long getId() {
		return this.id;
	}

	/**
	 * Assigns the surrogate identifier of the schedule.
	 *
	 * <p>
	 * This method exists exclusively for testing purposes and must not be used in
	 * production code. It allows controlled assignment of the identifier when
	 * working with manually constructed or detached entities in tests.
	 * </p>
	 *
	 * @param id the identifier to assign
	 */
	void setId(final Long id) {
		this.id = id;
	}

	/**
	 * Returns the human-readable name of the schedule.
	 *
	 * @return the name of the schedule
	 */
	public String getName() {
		return this.name;
	}

	/**
	 * Updates the human-readable name of the schedule.
	 *
	 * @param name the new name of the schedule; must not be blank or {@code null}
	 * @throws NullPointerException     if {@code name} is {@code null}
	 * @throws IllegalArgumentException if {@code name} is blank
	 */
	public void setName(final String name) {
		this.name = Strings.requireNonBlank(name, "name can't be null");
	}

	/**
	 * Returns the unique business code of the schedule.
	 *
	 * @return the natural identifier of the schedule
	 */
	public String getCode() {
		return this.code;
	}

	/**
	 * Returns an unmodifiable view of the rules that define this schedule.
	 *
	 * <p>
	 * The returned collection must not be modified directly. Any change to the
	 * rules must be performed through the provided mutator methods.
	 * </p>
	 *
	 * @return an unmodifiable set of {@link ScheduleRule} instances
	 */
	public Set<ScheduleRule> getRules() {
		return Collections.unmodifiableSet(this.rules);
	}

	/**
	 * Adds a rule to this schedule.
	 *
	 * @param rule the {@link ScheduleRule} to add; must not be {@code null}
	 * @return {@code true} if the rule was not already present
	 * @throws NullPointerException if {@code rule} is {@code null}
	 */
	public boolean addRule(final ScheduleRule rule) {
		Objects.requireNonNull(rule, "rule can't be null");
		return this.rules.add(rule);
	}

	/**
	 * Removes a rule from this schedule.
	 *
	 * @param rule the {@link ScheduleRule} to remove; must not be {@code null}
	 * @return {@code true} if the rule was present and removed
	 * @throws NullPointerException if {@code rule} is {@code null}
	 */
	public boolean removeRule(final ScheduleRule rule) {
		Objects.requireNonNull(rule, "rule can't be null");
		return this.rules.remove(rule);
	}

	/**
	 * Removes all rules from this schedule.
	 *
	 * <p>
	 * After invocation, the schedule will contain no temporal definitions.
	 * </p>
	 */
	public void clearRules() {
		this.rules.clear();
	}

	/**
	 * Returns an unmodifiable view of the employees assigned to this schedule.
	 *
	 * <p>
	 * The returned collection may be temporarily out of sync if employees are added
	 * to or removed from the schedule after the entity has been loaded and before
	 * this accessor is called.
	 * </p>
	 *
	 * @return an unmodifiable set of {@link Employee} entities
	 */
	public Set<Employee> getEmployees() {
		return Collections.unmodifiableSet(this.employees);
	}

	/**
	 * Replaces the set of employees assigned to this schedule.
	 *
	 * <p>
	 * This method exists exclusively for testing purposes and must not be used in
	 * production code.
	 * </p>
	 *
	 * @param employees the set of employees to associate with this schedule; must
	 *                  not be {@code null}
	 * @throws NullPointerException if {@code employees} is {@code null}
	 */
	void setEmployees(final Set<Employee> employees) {
		this.employees = Objects.requireNonNull(employees, "employees can't be null");
	}

	@Override
	public int hashCode() {
		return Objects.hash(this.code);
	}

	@Override
	public boolean equals(final Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || this.getClass() != obj.getClass()) {
			return false;
		}
		final Schedule other = (Schedule) obj;
		return Objects.equals(this.code, other.code);
	}

	@Override
	public String toString() {
		return this.code;
	}
}
