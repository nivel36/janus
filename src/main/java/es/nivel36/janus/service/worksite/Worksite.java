/*
 * Copyright 2026 Abel Ferrer Jim√©nez
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package es.nivel36.janus.service.worksite;

import java.io.Serializable;
import java.time.ZoneId;
import java.util.Collections;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import org.hibernate.annotations.NaturalId;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.SQLRestriction;

import es.nivel36.janus.service.employee.Employee;
import es.nivel36.janus.service.timelog.TimeLog;
import es.nivel36.janus.util.Strings;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;

/**
 * JPA entity representing a physical or virtual worksite where employees can
 * register {@link TimeLog} entries.
 *
 * <p>
 * A {@code Worksite} is uniquely identified by its natural identifier
 * ({@code code}) and has a human-readable {@code name}. Each worksite is
 * associated with a {@link ZoneId} that defines the local time zone used when
 * interpreting time-based data.
 * </p>
 *
 * <p>
 * <strong>Soft delete:</strong> this entity uses logical deletion via the
 * {@code deleted} flag. The Hibernate annotations
 * {@link org.hibernate.annotations.SQLDelete} and
 * {@link org.hibernate.annotations.SQLRestriction} ensure that delete operations
 * update the flag instead of physically removing the row, and that queries
 * exclude logically deleted records by default.
 * </p>
 *
 * <p>
 * Equality and hash code are based solely on the natural identifier
 * ({@code code}), which is assumed to be unique and immutable.
 * </p>
 *
 * @see Employee
 * @see TimeLog
 */
@SQLDelete(sql = "UPDATE WORKSITE SET deleted = true WHERE id = ?")
@SQLRestriction("deleted = false")
@Entity
public class Worksite implements Serializable {

	private static final long serialVersionUID = 1L;

	/**
	 * Surrogate primary key of the worksite.
	 *
	 * <p>
	 * This value is auto-generated by the persistence provider and has no business
	 * meaning.
	 * </p>
	 */
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	/**
	 * Human-readable name of the worksite.
	 *
	 * <p>
	 * This field is mandatory and must not be {@code null} or empty.
	 * </p>
	 */
	@NotEmpty
	private String name;

	/**
	 * Unique business code of the worksite.
	 *
	 * <p>
	 * Acts as a natural identifier for lookups and external references. This value
	 * is immutable once the entity has been persisted.
	 * </p>
	 */
	@NaturalId
	@NotEmpty
	@Column(updatable = false)
	private String code;

	/**
	 * Time zone associated with the worksite.
	 *
	 * <p>
	 * Determines how local dates and times are interpreted for this worksite. The
	 * value is persisted as a string (for example, {@code "Europe/Madrid"}) using
	 * a JPA {@link jakarta.persistence.Converter}.
	 * </p>
	 */
	@NotNull
	private ZoneId timeZone;

	/**
	 * Logical deletion flag.
	 *
	 * <p>
	 * When {@code true}, the worksite is considered deleted but remains stored in
	 * the database for auditing and historical purposes.
	 * </p>
	 */
	@NotNull
	private boolean deleted = false;

	/**
	 * Employees assigned to this worksite.
	 *
	 * <p>
	 * This is the inverse side of the many-to-many relationship defined in
	 * {@link Employee}. The returned collection must be treated as read-only from
	 * outside the entity.
	 * </p>
	 */
	@ManyToMany(mappedBy = "worksites")
	private Set<Employee> employees = new HashSet<>();

	/**
	 * Time logs registered at this worksite.
	 *
	 * <p>
	 * This association is lazily loaded. The returned collection must not be
	 * modified directly from outside the entity.
	 * </p>
	 */
	@OneToMany(mappedBy = "worksite", fetch = FetchType.LAZY)
	private Set<TimeLog> timeLogs = new HashSet<>();

	/**
	 * Protected no-argument constructor required by persistence frameworks.
	 *
	 * <p>
	 * This constructor must not be used directly in application code. It exists
	 * solely to allow frameworks such as JPA to instantiate the entity.
	 * </p>
	 */
	Worksite() {
	}

	/**
	 * Creates a new {@code Worksite} with the given attributes.
	 *
	 * @param code     the unique business code of the worksite; must not be
	 *                 {@code null} or blank
	 * @param name     the human-readable name of the worksite; must not be
	 *                 {@code null} or blank
	 * @param timeZone the time zone associated with the worksite; must not be
	 *                 {@code null}
	 *
	 * @throws NullPointerException if {@code timeZone} is {@code null}
	 * @throws IllegalArgumentException if {@code code} or {@code name} is blank
	 */
	public Worksite(final String code, final String name, final ZoneId timeZone) {
		this.code = Strings.requireNonBlank(code, "code can't be null or blank");
		this.name = Strings.requireNonBlank(name, "name can't be null or blank");
		this.timeZone = Objects.requireNonNull(timeZone, "timeZone can't be null");
	}

	/**
	 * Returns the surrogate identifier of the worksite.
	 *
	 * @return the internal identifier, or {@code null} if the entity has not yet
	 *         been persisted
	 */
	public Long getId() {
		return this.id;
	}

	/**
	 * Assigns the surrogate identifier of the worksite.
	 *
	 * <p>
	 * This method exists exclusively for testing purposes and must not be used in
	 * production code. It allows controlled assignment of the identifier when
	 * working with manually constructed or detached entities in tests.
	 * </p>
	 *
	 * @param id the identifier to assign
	 */
	void setId(final Long id) {
		this.id = id;
	}

	/**
	 * Returns the human-readable name of the worksite.
	 *
	 * @return the name of the worksite
	 */
	public String getName() {
		return this.name;
	}

	/**
	 * Updates the human-readable name of the worksite.
	 *
	 * @param name the new name of the worksite; must not be {@code null} or blank
	 * @throws IllegalArgumentException if {@code name} is blank
	 */
	public void setName(final String name) {
		this.name = Strings.requireNonBlank(name, "name can't be null or blank");
	}

	/**
	 * Returns the unique business code of the worksite.
	 *
	 * @return the natural identifier of the worksite
	 */
	public String getCode() {
		return this.code;
	}

	/**
	 * Returns the time zone associated with the worksite.
	 *
	 * @return the {@link ZoneId} of the worksite
	 */
	public ZoneId getTimeZone() {
		return this.timeZone;
	}

	/**
	 * Updates the time zone of the worksite.
	 *
	 * @param timeZone the new {@link ZoneId}; must not be {@code null}
	 * @throws NullPointerException if {@code timeZone} is {@code null}
	 */
	public void setTimeZone(final ZoneId timeZone) {
		this.timeZone = Objects.requireNonNull(timeZone, "timeZone can't be null");
	}

	/**
	 * Indicates whether this worksite is logically deleted.
	 *
	 * @return {@code true} if the worksite is marked as deleted; {@code false}
	 *         otherwise
	 */
	public boolean isDeleted() {
		return this.deleted;
	}

	/**
	 * Sets the logical deletion flag of this worksite.
	 *
	 * <p>
	 * This method exists exclusively for testing purposes and must not be used in
	 * production code.
	 * </p>
	 *
	 * @param deleted {@code true} to mark the worksite as deleted; {@code false}
	 *                otherwise
	 */
	void setDeleted(final boolean deleted) {
		this.deleted = deleted;
	}

	/**
	 * Returns an unmodifiable view of the employees assigned to this worksite.
	 *
	 * <p>
	 * The returned collection may be temporarily out of sync if employees are added
	 * to or removed from this worksite after the entity has been loaded and before
	 * this accessor is called.
	 * </p>
	 *
	 * @return an unmodifiable set of {@link Employee} entities
	 */
	public Set<Employee> getEmployees() {
		return Collections.unmodifiableSet(this.employees);
	}

	/**
	 * Replaces the set of employees assigned to this worksite.
	 *
	 * <p>
	 * This method exists exclusively for testing purposes and must not be used in
	 * production code.
	 * </p>
	 *
	 * @param employees the set of {@link Employee} entities to assign; must not be
	 *                  {@code null}
	 * @throws NullPointerException if {@code employees} is {@code null}
	 */
	void setEmployees(final Set<Employee> employees) {
		this.employees = Objects.requireNonNull(employees, "employees can't be null");
	}

	/**
	 * Returns an unmodifiable view of the time logs registered at this worksite.
	 *
	 * <p>
	 * The returned collection may be temporarily out of sync if time logs are added
	 * to or removed from this worksite after the entity has been loaded and before
	 * this accessor is called.
	 * </p>
	 *
	 * @return an unmodifiable set of {@link TimeLog} entities
	 */
	public Set<TimeLog> getTimeLogs() {
		return Collections.unmodifiableSet(this.timeLogs);
	}

	/**
	 * Replaces the set of time logs registered at this worksite.
	 *
	 * <p>
	 * This method exists exclusively for testing purposes and must not be used in
	 * production code.
	 * </p>
	 *
	 * @param timeLogs the set of {@link TimeLog} entities to assign; must not be
	 *                 {@code null}
	 * @throws NullPointerException if {@code timeLogs} is {@code null}
	 */
	void setTimeLogs(final Set<TimeLog> timeLogs) {
		this.timeLogs = Objects.requireNonNull(timeLogs, "timeLogs can't be null");
	}

	@Override
	public int hashCode() {
		return Objects.hash(this.code);
	}

	@Override
	public boolean equals(final Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || this.getClass() != obj.getClass()) {
			return false;
		}
		final Worksite other = (Worksite) obj;
		return Objects.equals(this.code, other.code);
	}

	@Override
	public String toString() {
		return this.code;
	}
}
