/*
 * Copyright 2026 Abel Ferrer Jim√©nez
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package es.nivel36.janus.service.employee;

import java.io.Serializable;
import java.util.Collections;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import org.hibernate.annotations.NaturalId;

import es.nivel36.janus.service.schedule.Schedule;
import es.nivel36.janus.service.timelog.TimeLog;
import es.nivel36.janus.service.worksite.Worksite;
import es.nivel36.janus.util.Strings;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;

/**
 * Entity representing an employee. This entity contains personal information
 * about the employee and maintains a list of time logs associated with the
 * employee.
 *
 * <p>
 * Each employee is uniquely identified by their email address. In addition to
 * time logs, the employee also has an associated work schedule represented by a
 * {@link Schedule} entity, which is mandatory and cannot be null.
 * </p>
 *
 * @see TimeLog
 */
/**
 * JPA entity representing an employee of the system.
 *
 * <p>
 * An {@code Employee} models a person who can register time logs at one or more
 * worksites and who operates under a specific {@link Schedule}. The entity is
 * identified internally by a surrogate primary key, while the {@code email}
 * field acts as a natural identifier with business meaning.
 * </p>
 *
 * <p>
 * Equality and hash code are based solely on the natural identifier
 * ({@code email}), assuming it is immutable and unique across the system.
 * </p>
 */
@Entity
public class Employee implements Serializable {

	private static final long serialVersionUID = 1L;

	/**
	 * Surrogate primary key of the employee.
	 *
	 * <p>
	 * This value is auto-generated by the persistence provider and has no business
	 * meaning. It must not be relied upon for equality comparisons.
	 * </p>
	 */
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	/**
	 * The first name of the employee.
	 *
	 * <p>
	 * This field is mandatory and must not be {@code null} or blank.
	 * </p>
	 */
	@NotEmpty
	private String name;

	/**
	 * The surname of the employee.
	 *
	 * <p>
	 * This field is mandatory and must not be {@code null} or blank.
	 * </p>
	 */
	@NotEmpty
	private String surname;

	/**
	 * The email address of the employee.
	 *
	 * <p>
	 * Acts as a natural identifier. This field is mandatory, must be unique, and
	 * cannot be updated once the entity has been persisted.
	 * </p>
	 */
	@NaturalId
	@NotEmpty
	@Email
	@Column(updatable = false)
	private String email;

	/**
	 * The work schedule assigned to this employee.
	 *
	 * <p>
	 * This association is mandatory and defines the expected working hours of the
	 * employee.
	 * </p>
	 */
	@NotNull
	@ManyToOne(optional = false, fetch = FetchType.LAZY)
	@JoinColumn(name = "schedule_id")
	private Schedule schedule;

	/**
	 * The worksites where this employee is allowed to register time logs.
	 *
	 * <p>
	 * This is a many-to-many association. The returned collection should not be
	 * modified directly from outside the entity.
	 * </p>
	 */
	@ManyToMany
	@JoinTable(name = "employee_worksite", joinColumns = @JoinColumn(name = "employee_id"), inverseJoinColumns = @JoinColumn(name = "worksite_id"))
	private Set<Worksite> worksites = new HashSet<>();

	/**
	 * The set of time logs registered by this employee.
	 *
	 * <p>
	 * This association is lazily loaded. The returned collection should be treated
	 * as read-only from outside the entity.
	 * </p>
	 */
	@OneToMany(mappedBy = "employee", fetch = FetchType.LAZY)
	private Set<TimeLog> timeLogs = new HashSet<>();

	/**
	 * Protected no-argument constructor required by persistence frameworks.
	 *
	 * <p>
	 * This constructor must not be used directly in application code. It exists
	 * solely to allow frameworks such as JPA to instantiate the entity.
	 * </p>
	 */
	Employee() {
	}

	/**
	 * Constructs a new {@code Employee} with the given personal data and schedule.
	 *
	 * @param name     the first name of the employee; must not be {@code null} or
	 *                 blank
	 * @param surname  the surname of the employee; must not be {@code null} or
	 *                 blank
	 * @param email    the unique email address of the employee; must not be
	 *                 {@code null} or blank
	 * @param schedule the work schedule assigned to the employee; must not be
	 *                 {@code null}
	 *                 
	 * @throws NullPointerException if name, surname, email or schedule is {@code null}
	 * @throws IllegalArgumentException if name, surname, email is empty
	 * 
	 */
	public Employee(final String name, final String surname, final String email, final Schedule schedule) {
		this.name = Strings.requireNonBlank(name, "name can't be null or blank");
		this.surname = Strings.requireNonBlank(surname, "surname can't be null or blank");
		this.email = Strings.requireNonBlank(email, "email can't be null or blank");
		this.schedule = Objects.requireNonNull(schedule, "schedule can't be null");
	}

	/**
	 * Returns the surrogate identifier of the employee.
	 *
	 * @return the internal identifier, or {@code null} if the entity has not yet
	 *         been persisted
	 */
	public Long getId() {
		return this.id;
	}

	/**
	 * Returns the first name of the employee.
	 *
	 * @return the first name
	 */
	public String getName() {
		return this.name;
	}

	/**
	 * Returns the surname of the employee.
	 *
	 * @return the surname
	 */
	public String getSurname() {
		return this.surname;
	}

	/**
	 * Returns the email address of the employee.
	 *
	 * @return the email address
	 */
	public String getEmail() {
		return this.email;
	}

	/**
	 * Returns the work schedule assigned to the employee.
	 *
	 * @return the {@link Schedule} associated with this employee
	 */
	public Schedule getSchedule() {
		return this.schedule;
	}

	/**
	 * Returns an unmodifiable view of the time logs registered by this employee.
	 *
	 * <p>
	 * The returned collection may be temporarily out of sync if time logs are added
	 * or removed after the entity has been loaded and before this accessor is
	 * called.
	 * </p>
	 *
	 * @return an unmodifiable set of {@link TimeLog} instances
	 */
	public Set<TimeLog> getTimeLogs() {
		return Collections.unmodifiableSet(this.timeLogs);
	}

	/**
	 * Returns an unmodifiable view of the worksites assigned to this employee.
	 *
	 * @return an unmodifiable set of {@link Worksite} entities
	 */
	public Set<Worksite> getWorksites() {
		return Collections.unmodifiableSet(this.worksites);
	}

	/**
	 * Assigns the surrogate identifier of the employee.
	 *
	 * <p>
	 * This method exists exclusively for testing purposes and must not be used in
	 * production code. It allows controlled assignment of the identifier when
	 * working with detached or manually constructed entities in tests.
	 * </p>
	 *
	 * @param id the identifier to assign
	 */
	void setId(final Long id) {
		this.id = id;
	}

	/**
	 * Assigns a new work schedule to the employee.
	 *
	 * @param schedule the {@link Schedule} to assign; must not be {@code null}
	 * 
	 * @throws NullPointerException     if schedule is {@code null}
	 */
	public void setSchedule(final Schedule schedule) {
		this.schedule = Objects.requireNonNull(schedule, "schedule can't be null");
	}

	/**
	 * Updates the full name of the employee.
	 *
	 * @param name    the new first name; must not be {@code null} or blank
	 * @param surname the new surname; must not be {@code null} or blank
	 * 
	 * @throws NullPointerException     if name or surname is {@code null}
	 * @throws IllegalArgumentException if name or surname is blank
	 */
	public void setFullName(final String name, final String surname) {
		this.name = Strings.requireNonBlank(name, "name can't be null or blank");
		this.surname = Strings.requireNonBlank(surname, "surname can't be null or blank");
	}

	/**
	 * Replaces the set of time logs associated with this employee.
	 *
	 * <p>
	 * This method is intended for testing purposes only and must not be used in
	 * production code.
	 * </p>
	 *
	 * @param timeLogs the set of {@link TimeLog} entries to assign; must not be
	 *                 {@code null}
	 *                 
	 * @throws NullPointerException if timeLogs is {@code null}
	 */
	void setTimeLogs(final Set<TimeLog> timeLogs) {
		this.timeLogs = Objects.requireNonNull(timeLogs, "timeLogs can't be null");
	}

	/**
	 * Assigns this employee to the given worksite.
	 *
	 * @param worksite the {@link Worksite} to assign; must not be {@code null}
	 * @return {@code true} if the worksite was not already assigned
	 * 
	 * @throws NullPointerException if worksite is {@code null}
	 */
	public boolean assignToWorksite(final Worksite worksite) {
		Objects.requireNonNull(worksite, "worksite can't be null");
		return this.worksites.add(worksite);
	}

	/**
	 * Removes this employee from the given worksite.
	 *
	 * @param worksite the {@link Worksite} to remove; must not be {@code null}
	 * @return {@code true} if the worksite was previously assigned
	 * 
	 * @throws NullPointerException if worksite is {@code null}
	 */
	public boolean removeFromWorksite(final Worksite worksite) {
		Objects.requireNonNull(worksite, "worksite can't be null");
		return this.worksites.remove(worksite);
	}

	@Override
	public boolean equals(final Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || this.getClass() != obj.getClass()) {
			return false;
		}
		final Employee other = (Employee) obj;
		return Objects.equals(this.email, other.email);
	}

	@Override
	public int hashCode() {
		return Objects.hash(this.email);
	}

	@Override
	public String toString() {
		return this.email;
	}
}
