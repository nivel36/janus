/*
 * Copyright 2025 Abel Ferrer Jim√©nez
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package es.nivel36.janus.service.workshift;

import java.io.Serializable;
import java.time.Duration;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import es.nivel36.janus.service.employee.Employee;
import es.nivel36.janus.service.timelog.TimeLog;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.validation.constraints.NotNull;

/**
 * JPA entity representing a work shift of an employee.
 *
 * <p>
 * A {@code WorkShift} aggregates all {@link TimeLog} entries that belong to a
 * single working day for a given {@link Employee}. It models the effective
 * working periods (clock-ins and clock-outs) as well as the accumulated pause
 * time, allowing the system to derive total worked and break durations.
 * </p>
 *
 * <p>
 * The entity is identified internally by a surrogate primary key. From a
 * business perspective, a work shift is uniquely identified by the combination
 * of {@code employee} and {@code date}.
 * </p>
 *
 * @see TimeLog
 * @see Employee
 */
@Entity
public class WorkShift implements Serializable {

	private static final long serialVersionUID = 1L;

	/**
	 * Surrogate primary key of the work shift.
	 *
	 * <p>
	 * This value is auto-generated by the persistence provider and has no business
	 * meaning.
	 * </p>
	 */
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;

	/**
	 * The employee to whom this work shift belongs.
	 *
	 * <p>
	 * This association is mandatory and immutable once the shift has been
	 * persisted.
	 * </p>
	 */
	@NotNull
	@ManyToOne(optional = false)
	@JoinColumn(name = "employee_id", updatable = false)
	private Employee employee;

	/**
	 * The calendar date on which the work shift started.
	 *
	 * <p>
	 * This value is mandatory and immutable once the entity is persisted.
	 * </p>
	 */
	@NotNull
	@Column(updatable = false)
	private LocalDate date;

	/**
	 * The ordered list of time logs (clock-ins and clock-outs) associated with this
	 * work shift.
	 *
	 * <p>
	 * The returned collection must be treated as read-only from outside the entity.
	 * Modifications should be performed through domain logic.
	 * </p>
	 */
	@OneToMany
	@JoinTable(name = "workshift_timelog", joinColumns = @JoinColumn(name = "workshift_id"), inverseJoinColumns = @JoinColumn(name = "timelog_id"))
	private List<TimeLog> timeLogs = new ArrayList<>();

	/**
	 * Total time spent on pauses during this work shift.
	 *
	 * <p>
	 * This value represents the accumulated duration of all break periods and is
	 * never {@code null}.
	 * </p>
	 */
	@NotNull
	private Duration totalPauseTime = Duration.ZERO;

	/**
	 * Total effective working time during this work shift.
	 *
	 * <p>
	 * This value represents the accumulated duration of active working periods and
	 * is never {@code null}.
	 * </p>
	 */
	@NotNull
	private Duration totalWorkTime = Duration.ZERO;

	/**
	 * Protected no-argument constructor required by persistence frameworks.
	 *
	 * <p>
	 * This constructor must not be used directly in application code. It exists
	 * solely to allow frameworks such as JPA to instantiate the entity.
	 * </p>
	 */
	WorkShift() {
	}

	/**
	 * Creates a new {@code WorkShift} for the given employee and date.
	 *
	 * <p>
	 * The work shift is initialized with the provided list of time logs. The list
	 * reference itself is stored, so callers must not subsequently modify it
	 * directly.
	 * </p>
	 *
	 * @param employee the employee assigned to this work shift; must not be
	 *                 {@code null}
	 * @param date     the date on which the work shift started; must not be
	 *                 {@code null}
	 * @param timeLogs the list of {@link TimeLog} entries associated with this
	 *                 shift; must not be {@code null}
	 *
	 * @throws NullPointerException if {@code employee}, {@code date}, or
	 *                              {@code timeLogs} is {@code null}
	 */
	public WorkShift(final Employee employee, final LocalDate date, final List<TimeLog> timeLogs) {
		this.employee = Objects.requireNonNull(employee, "employee can't be null");
		this.date = Objects.requireNonNull(date, "date can't be null");
		this.timeLogs = Objects.requireNonNull(timeLogs, "timeLogs can't be null");
	}

	/**
	 * Returns the surrogate identifier of this work shift.
	 *
	 * @return the internal identifier, or {@code null} if the entity has not yet
	 *         been persisted
	 */
	public Long getId() {
		return this.id;
	}

	/**
	 * Returns the employee associated with this work shift.
	 *
	 * @return the {@link Employee} assigned to this work shift
	 */
	public Employee getEmployee() {
		return this.employee;
	}

	/**
	 * Returns the date on which the work shift started.
	 *
	 * @return the start date of the work shift
	 */
	public LocalDate getDate() {
		return this.date;
	}

	/**
	 * Returns an unmodifiable view of the time logs associated with this work
	 * shift.
	 *
	 * <p>
	 * The returned list may be temporarily out of sync if time logs are added or
	 * removed after the entity has been loaded and before this accessor is called.
	 * </p>
	 *
	 * @return an unmodifiable list of {@link TimeLog} entries
	 */
	public List<TimeLog> getTimeLogs() {
		return Collections.unmodifiableList(this.timeLogs);
	}

	/**
	 * Returns the total pause time accumulated during this work shift.
	 *
	 * @return the total pause time; never {@code null}
	 */
	public Duration getTotalPauseTime() {
		return this.totalPauseTime;
	}

	/**
	 * Returns the total effective working time accumulated during this work shift.
	 *
	 * @return the total working time; never {@code null}
	 */
	public Duration getTotalWorkTime() {
		return this.totalWorkTime;
	}

	/**
	 * Assigns the surrogate identifier of the work shift.
	 *
	 * <p>
	 * This method exists exclusively for testing purposes and must not be used in
	 * production code. It allows controlled assignment of the identifier when
	 * working with manually constructed or detached entities in tests.
	 * </p>
	 *
	 * @param id the identifier to assign
	 */
	void setId(final Long id) {
		this.id = id;
	}

	/**
	 * Updates the total pause time of this work shift.
	 *
	 * @param totalPauseTime the new total pause time; must not be {@code null}
	 *
	 * @throws NullPointerException if {@code totalPauseTime} is {@code null}
	 */
	public void setTotalPauseTime(final Duration totalPauseTime) {
		this.totalPauseTime = Objects.requireNonNull(totalPauseTime, "totalPauseTime can't be null");
	}

	/**
	 * Updates the total effective working time of this work shift.
	 *
	 * @param totalWorkTime the new total working time; must not be {@code null}
	 *
	 * @throws NullPointerException if {@code totalWorkTime} is {@code null}
	 */
	public void setTotalWorkTime(final Duration totalWorkTime) {
		this.totalWorkTime = Objects.requireNonNull(totalWorkTime, "totalWorkTime can't be null");
	}

	@Override
	public boolean equals(final Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || this.getClass() != obj.getClass()) {
			return false;
		}
		final WorkShift other = (WorkShift) obj;
		return Objects.equals(this.employee, other.employee) && Objects.equals(this.date, other.date);
	}

	@Override
	public int hashCode() {
		return Objects.hash(this.employee, this.date);
	}

	@Override
	public String toString() {
		return "WorkShift [id=" + id + (employee != null ? ", employee=" + employee.getName() : "") + ", date="
				+ (date != null ? date : "null") + "]";
	}
}
